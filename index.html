<!DOCTYPE html>
<html>
  <body>

    <div id="parent">
    </div>

    <p>Sample text to see if shit is working</p>

    <script>
      class Node {
	  constructor(xx, yy, data) {
	      this.xx = xx;
	      this.yy = yy;
	      this.data = data;
	      this.dampening = 0.8;

	      this.omniForce = 0; // Force in all directions
	      this.fx = 0;
	      this.fy = 0;
	      this.nextFx = 0;
	      this.nextFy = 0;
	      this.isAddedToUpdate = false;
	      this.asciiShades = ["M", "@", "G", "O", "C", "c", "+", ";", ":", ",", "."].reverse();
	      this.asciiThreshold = [];
	      for (var index = 0; index < this.asciiShades.length; ++index) {
		  this.asciiThreshold.push(index * 100.0/(this.asciiShades.length-1));
	      }
	  }
	  getNodeElement() {
	      this.element = document.createElement("p");
	      this.element.className = "cell";
	      this.element.style.display = "block";
	      this.element.style.width = "100%";
	      this.element.style.height = "100%";
	      this.element.innerText = ".";
	      this.element.onclick = () => this.startRipple();
	      return this.element;
	  }
	  startRipple() {
	      this.omniForce = 100.0;
	      this.element.innerText = this.asciiShades[this.asciiShades.length-1];
	      for (var yChange = -1; yChange <=1; ++yChange) {
		  for (var xChange = -1; xChange <=1; ++xChange) {
		      this.data.addToUpdateQueue(this.xx+xChange, this.yy+yChange);
		  }
	      }
	  }
	  updateForces(xChange, yChange, xForce, yForce) {
	      if (xChange == 0 || yChange == 0) { // Orthongonal
		  this.nextFy += yForce;
		  this.nextFx += xForce;
	      }
	      else {
		  this.nextFy += yForce * 0.7;
		  this.nextFx += xForce * 0.7;
	      }
	      // console.log("updated forces to: ", this.nextFy, this.nextFx);
	  }
	  updateNode() {
	      this.element.style.background = "green";
	      for (var yChange = -1; yChange <=1; ++yChange) {
		  for (var xChange = -1; xChange <=1; ++xChange) {
		      if (yChange == 0 && xChange == 0) continue;
		      var node = this.data.getNode(this.xx + xChange, this.yy + yChange);
		      if (node == undefined) continue;
		      // console.log("updated forces from(", node.xx, ", ", node.yy, "): ", this.nextFy, this.nextFx);
		      if (node.omniForce != 0) {
			  // console.log("omniforce guy");
			  this.updateForces(xChange, yChange, -xChange*node.omniForce, -yChange*node.omniForce);
		      }
		      else {
			  var deltaFx = 0, deltaFy = 0;
			  if (xChange == 0 || yChange == 0) {
			      if (xChange * node.fx < 0)
				  deltaFx = node.fx;
			      if (yChange * node.fy < 0)
				  deltaFy = node.fy;
			  }
			  else if (xChange * node.fx < 0 && yChange * node.fy < 0) {
			      deltaFx = node.fx;
			      deltaFy = node.fy;
			  }
			  this.updateForces(xChange, yChange, deltaFx, deltaFy);
		      }
		  }
	      }
	      // console.log("final force: (", this.xx, ", ", this.yy, ") ", this.nextFx, " : ", this.nextFy);
	      if (this.nextFx != 0 || this.nextFy != 0) {
		  for (var yChange = 0; yChange <= (this.nextFy!=0); ++yChange) {
		      for (var xChange = 0; xChange <= (this.nextFx!=0); ++xChange) {
			  this.data.addToUpdateQueue(this.xx + Math.sign(this.nextFx)*xChange,
						     this.yy + Math.sign(this.nextFy)*yChange);
		      }
		  }
	      }
	      this.data.addToDrawQueue(this.xx, this.yy);
	      this.element.style.background = "none";
	  }
	  drawNode() {
	      // console.log("fx: ", this.fx, "fy: ", this.fy, "nfx: ", this.nextFx, "nfy: ", this.nextFy);
	      this.omniForce = 0;
	      this.fx = this.nextFx * this.dampening;
	      this.fy = this.nextFy * this.dampening;
	      this.nextFx = 0;
	      this.nextFy = 0;
	      var magnitude = Math.sqrt(Math.pow(this.fx, 2) + Math.pow(this.fy, 2));
	      if (magnitude > 100) magnitude = 100;
	      var index = this.asciiThreshold.findIndex((el) => el >= magnitude);
	      this.element.innerText = this.asciiShades[index];
	  }
      }

      class AsciiRippleData {
	  constructor(numRows, numCols) {
	      this.nodeList = [];
	      this.updateQueue = [];
	      this.drawQueue = [];
	      this.isUpdateDone = true;
	      this.numRows = numRows;
	      this.numCols = numCols;
	  }
	  appendNode(node) {
	      this.nodeList.push(node);
	  }
	  getNode(xx, yy) {
	      if (xx < 0 || xx >= this.numCols ||
		  yy < 0 || yy >= this.numRows)
		  return undefined;
	      return this.nodeList[ yy*this.numCols + xx ];
	  }
	  addToUpdateQueue(xx, yy) {
	      // console.log("Trying adding to update queue: ", xx, " : ", yy);
	      if (xx < 0 || xx >= this.numCols ||
		  yy < 0 || yy >= this.numRows)
		  return;
	      var index = yy*this.numCols + xx;
	      if (!this.nodeList[index].isAddedToUpdate) {
		  // console.log("Added to update queue: ", xx, " : ", yy);
		  this.updateQueue.push(index);
		  this.nodeList[index].isAddedToUpdate = true;
	      }
	  }
	  addToDrawQueue(xx, yy) {
	      var index = yy*this.numCols + xx;
	      // Adding to draw is only done on self and so no errors should pop up
	      // if (index < 0 || index >= this.nodeList.length)
	      // 	  return;
	      this.drawQueue.push(index);
	  }
	  drawElements() {
	      var drawList = this.drawQueue;
	      this.drawQueue = [];
	      for (const index of drawList) {
		  var node = this.nodeList[index];
		  node.drawNode();
	      }
	  }
	  updateElements() {
	      this.isUpdateDone = false;
	      // console.log("Updating elements: ", this.updateQueue);
	      var updateList = this.updateQueue;
	      this.updateQueue = [];
	      for (const index of updateList) {
		  var node = this.nodeList[index];
		  node.isAddedToUpdate = false;
	      }
	      for (const index of updateList) {
		  var node = this.nodeList[index];
		  node.updateNode();
	      }
	      this.drawElements();
	      this.isUpdateDone = true;
	  }
      }

      class AsciiRipple {
	  constructor(elementID, numCols, numRows, updateInterval=300) {
	      this.parentNode = document.getElementById(elementID);
	      this.numRows = numRows;
	      this.numCols = numCols;
	      this.data = new AsciiRippleData(numRows, numCols);

	      this.setupGrid();
	      setInterval(() => this.tryUpdateElements(), updateInterval);
	  }
	  setupGrid() {
	      this.parentNode.style.display = "grid";
	      this.parentNode.style.gridTemplateColumns = "repeat(" + this.numCols + ", 1.5ch)"; // Make these Node static constants
	      this.parentNode.style.gridTemplateRows = "repeat(" + this.numRows + ", 1em)";
	      for (let yy = 0; yy < this.numRows; ++yy) {
		  for (let xx = 0; xx < this.numCols; ++xx) {
		      var node = new Node(xx, yy, this.data);
		      this.data.appendNode(node);
		      this.parentNode.appendChild(node.getNodeElement());
		  }
	      }
	  }
	  tryUpdateElements() {
	      if (this.data.isUpdateDone)
		  this.data.updateElements()
	      else
		  console.log("Previous update not completed, skipping update");
	  }
      }

      var ar = new AsciiRipple("parent", 100, 40, 100);

    </script>

  </body>
</html>
